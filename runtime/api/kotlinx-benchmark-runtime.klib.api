// Klib ABI Dump
// Targets: [androidNativeArm32, androidNativeArm64, androidNativeX64, androidNativeX86, iosArm64, iosSimulatorArm64, iosX64, js.jsIr, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, wasmJs, watchosArm32, watchosArm64, watchosDeviceArm64, watchosSimulatorArm64, watchosX64]
// Alias: native => [androidNativeArm32, androidNativeArm64, androidNativeX64, androidNativeX86, iosArm64, iosSimulatorArm64, iosX64, linuxArm64, linuxX64, macosArm64, macosX64, mingwX64, tvosArm64, tvosSimulatorArm64, tvosX64, watchosArm32, watchosArm64, watchosDeviceArm64, watchosSimulatorArm64, watchosX64]
// Rendering settings:
// - Signature version: 2
// - Show manifest properties: true
// - Show declarations: true

// Library unique name: <org.jetbrains.kotlinx:kotlinx-benchmark-runtime>
abstract class <#A: kotlin/Any?> kotlinx.benchmark/BenchmarkDescriptor { // kotlinx.benchmark/BenchmarkDescriptor|null[0]
    constructor <init>(kotlin/String, kotlinx.benchmark/SuiteDescriptor<#A>, kotlinx.benchmark/Blackhole) // kotlinx.benchmark/BenchmarkDescriptor.<init>|<init>(kotlin.String;kotlinx.benchmark.SuiteDescriptor<1:0>;kotlinx.benchmark.Blackhole){}[0]
    final val blackhole // kotlinx.benchmark/BenchmarkDescriptor.blackhole|{}blackhole[0]
        final fun <get-blackhole>(): kotlinx.benchmark/Blackhole // kotlinx.benchmark/BenchmarkDescriptor.blackhole.<get-blackhole>|<get-blackhole>(){}[0]
    final val name // kotlinx.benchmark/BenchmarkDescriptor.name|{}name[0]
        final fun <get-name>(): kotlin/String // kotlinx.benchmark/BenchmarkDescriptor.name.<get-name>|<get-name>(){}[0]
    final val suite // kotlinx.benchmark/BenchmarkDescriptor.suite|{}suite[0]
        final fun <get-suite>(): kotlinx.benchmark/SuiteDescriptor<#A> // kotlinx.benchmark/BenchmarkDescriptor.suite.<get-suite>|<get-suite>(){}[0]
}
abstract class kotlinx.benchmark/BenchmarkProgress { // kotlinx.benchmark/BenchmarkProgress|null[0]
    abstract fun endBenchmark(kotlin/String, kotlin/String, kotlinx.benchmark/BenchmarkProgress.FinishStatus, kotlin/String) // kotlinx.benchmark/BenchmarkProgress.endBenchmark|endBenchmark(kotlin.String;kotlin.String;kotlinx.benchmark.BenchmarkProgress.FinishStatus;kotlin.String){}[0]
    abstract fun endBenchmarkException(kotlin/String, kotlin/String, kotlin/String, kotlin/String) // kotlinx.benchmark/BenchmarkProgress.endBenchmarkException|endBenchmarkException(kotlin.String;kotlin.String;kotlin.String;kotlin.String){}[0]
    abstract fun endSuite(kotlin/String, kotlin/String) // kotlinx.benchmark/BenchmarkProgress.endSuite|endSuite(kotlin.String;kotlin.String){}[0]
    abstract fun output(kotlin/String, kotlin/String, kotlin/String) // kotlinx.benchmark/BenchmarkProgress.output|output(kotlin.String;kotlin.String;kotlin.String){}[0]
    abstract fun startBenchmark(kotlin/String, kotlin/String) // kotlinx.benchmark/BenchmarkProgress.startBenchmark|startBenchmark(kotlin.String;kotlin.String){}[0]
    abstract fun startSuite(kotlin/String) // kotlinx.benchmark/BenchmarkProgress.startSuite|startSuite(kotlin.String){}[0]
    constructor <init>() // kotlinx.benchmark/BenchmarkProgress.<init>|<init>(){}[0]
    final enum class FinishStatus : kotlin/Enum<kotlinx.benchmark/BenchmarkProgress.FinishStatus> { // kotlinx.benchmark/BenchmarkProgress.FinishStatus|null[0]
        enum entry Failure // kotlinx.benchmark/BenchmarkProgress.FinishStatus.Failure|null[0]
        enum entry Success // kotlinx.benchmark/BenchmarkProgress.FinishStatus.Success|null[0]
        final fun valueOf(kotlin/String): kotlinx.benchmark/BenchmarkProgress.FinishStatus // kotlinx.benchmark/BenchmarkProgress.FinishStatus.valueOf|valueOf#static(kotlin.String){}[0]
        final fun values(): kotlin/Array<kotlinx.benchmark/BenchmarkProgress.FinishStatus> // kotlinx.benchmark/BenchmarkProgress.FinishStatus.values|values#static(){}[0]
        final val entries // kotlinx.benchmark/BenchmarkProgress.FinishStatus.entries|#static{}entries[0]
            final fun <get-entries>(): kotlin.enums/EnumEntries<kotlinx.benchmark/BenchmarkProgress.FinishStatus> // kotlinx.benchmark/BenchmarkProgress.FinishStatus.entries.<get-entries>|<get-entries>#static(){}[0]
    }
    final object Companion { // kotlinx.benchmark/BenchmarkProgress.Companion|null[0]
        final fun create(kotlin/String, kotlin/Function0<kotlinx.benchmark/BenchmarkProgress>? =...): kotlinx.benchmark/BenchmarkProgress // kotlinx.benchmark/BenchmarkProgress.Companion.create|create(kotlin.String;kotlin.Function0<kotlinx.benchmark.BenchmarkProgress>?){}[0]
    }
}
abstract class kotlinx.benchmark/CommonSuiteExecutor : kotlinx.benchmark/SuiteExecutor { // kotlinx.benchmark/CommonSuiteExecutor|null[0]
    constructor <init>(kotlin/String, kotlin/String, kotlin/Function0<kotlinx.benchmark/BenchmarkProgress>? =...) // kotlinx.benchmark/CommonSuiteExecutor.<init>|<init>(kotlin.String;kotlin.String;kotlin.Function0<kotlinx.benchmark.BenchmarkProgress>?){}[0]
    open fun <#A1: kotlin/Any?> createIterationMeasurer(#A1, kotlinx.benchmark/BenchmarkDescriptor<#A1>, kotlinx.benchmark/BenchmarkConfiguration, kotlin/Int): kotlin/Function0<kotlin/Long> // kotlinx.benchmark/CommonSuiteExecutor.createIterationMeasurer|createIterationMeasurer(0:0;kotlinx.benchmark.BenchmarkDescriptor<0:0>;kotlinx.benchmark.BenchmarkConfiguration;kotlin.Int){0ยง<kotlin.Any?>}[0]
    open fun run(kotlinx.benchmark/RunnerConfiguration, kotlin.collections/List<kotlinx.benchmark/BenchmarkDescriptor<kotlin/Any?>>, kotlin/Function0<kotlin/Unit>, kotlin/Function0<kotlin/Unit>) // kotlinx.benchmark/CommonSuiteExecutor.run|run(kotlinx.benchmark.RunnerConfiguration;kotlin.collections.List<kotlinx.benchmark.BenchmarkDescriptor<kotlin.Any?>>;kotlin.Function0<kotlin.Unit>;kotlin.Function0<kotlin.Unit>){}[0]
}
abstract class kotlinx.benchmark/SuiteExecutor { // kotlinx.benchmark/SuiteExecutor|null[0]
    abstract fun run(kotlinx.benchmark/RunnerConfiguration, kotlin.collections/List<kotlinx.benchmark/BenchmarkDescriptor<kotlin/Any?>>, kotlin/Function0<kotlin/Unit>, kotlin/Function0<kotlin/Unit>) // kotlinx.benchmark/SuiteExecutor.run|run(kotlinx.benchmark.RunnerConfiguration;kotlin.collections.List<kotlinx.benchmark.BenchmarkDescriptor<kotlin.Any?>>;kotlin.Function0<kotlin.Unit>;kotlin.Function0<kotlin.Unit>){}[0]
    constructor <init>(kotlin/String, kotlin/String, kotlin/Function0<kotlinx.benchmark/BenchmarkProgress>? =...) // kotlinx.benchmark/SuiteExecutor.<init>|<init>(kotlin.String;kotlin.String;kotlin.Function0<kotlinx.benchmark.BenchmarkProgress>?){}[0]
    final fun <#A1: kotlin/Any?> suite(kotlinx.benchmark/SuiteDescriptor<#A1>) // kotlinx.benchmark/SuiteExecutor.suite|suite(kotlinx.benchmark.SuiteDescriptor<0:0>){0ยง<kotlin.Any?>}[0]
    final fun id(kotlin/String, kotlin.collections/Map<kotlin/String, kotlin/String>): kotlin/String // kotlinx.benchmark/SuiteExecutor.id|id(kotlin.String;kotlin.collections.Map<kotlin.String,kotlin.String>){}[0]
    final fun result(kotlinx.benchmark/ReportBenchmarkResult) // kotlinx.benchmark/SuiteExecutor.result|result(kotlinx.benchmark.ReportBenchmarkResult){}[0]
    final fun run() // kotlinx.benchmark/SuiteExecutor.run|run(){}[0]
    final val executionName // kotlinx.benchmark/SuiteExecutor.executionName|{}executionName[0]
        final fun <get-executionName>(): kotlin/String // kotlinx.benchmark/SuiteExecutor.executionName.<get-executionName>|<get-executionName>(){}[0]
    final val reporter // kotlinx.benchmark/SuiteExecutor.reporter|{}reporter[0]
        final fun <get-reporter>(): kotlinx.benchmark/BenchmarkProgress // kotlinx.benchmark/SuiteExecutor.reporter.<get-reporter>|<get-reporter>(){}[0]
}
final class kotlinx.benchmark/BenchmarkConfiguration { // kotlinx.benchmark/BenchmarkConfiguration|null[0]
    constructor <init>(kotlinx.benchmark/RunnerConfiguration, kotlinx.benchmark/SuiteDescriptor<*>) // kotlinx.benchmark/BenchmarkConfiguration.<init>|<init>(kotlinx.benchmark.RunnerConfiguration;kotlinx.benchmark.SuiteDescriptor<*>){}[0]
    final fun toString(): kotlin/String // kotlinx.benchmark/BenchmarkConfiguration.toString|toString(){}[0]
    final object Companion { // kotlinx.benchmark/BenchmarkConfiguration.Companion|null[0]
        final fun parse(kotlin/String): kotlinx.benchmark/BenchmarkConfiguration // kotlinx.benchmark/BenchmarkConfiguration.Companion.parse|parse(kotlin.String){}[0]
    }
    final val advanced // kotlinx.benchmark/BenchmarkConfiguration.advanced|{}advanced[0]
        final fun <get-advanced>(): kotlin.collections/Map<kotlin/String, kotlin/String> // kotlinx.benchmark/BenchmarkConfiguration.advanced.<get-advanced>|<get-advanced>(){}[0]
    final val iterationTime // kotlinx.benchmark/BenchmarkConfiguration.iterationTime|{}iterationTime[0]
        final fun <get-iterationTime>(): kotlin/Long // kotlinx.benchmark/BenchmarkConfiguration.iterationTime.<get-iterationTime>|<get-iterationTime>(){}[0]
    final val iterationTimeUnit // kotlinx.benchmark/BenchmarkConfiguration.iterationTimeUnit|{}iterationTimeUnit[0]
        final fun <get-iterationTimeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/BenchmarkConfiguration.iterationTimeUnit.<get-iterationTimeUnit>|<get-iterationTimeUnit>(){}[0]
    final val iterations // kotlinx.benchmark/BenchmarkConfiguration.iterations|{}iterations[0]
        final fun <get-iterations>(): kotlin/Int // kotlinx.benchmark/BenchmarkConfiguration.iterations.<get-iterations>|<get-iterations>(){}[0]
    final val mode // kotlinx.benchmark/BenchmarkConfiguration.mode|{}mode[0]
        final fun <get-mode>(): kotlinx.benchmark/Mode // kotlinx.benchmark/BenchmarkConfiguration.mode.<get-mode>|<get-mode>(){}[0]
    final val outputTimeUnit // kotlinx.benchmark/BenchmarkConfiguration.outputTimeUnit|{}outputTimeUnit[0]
        final fun <get-outputTimeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/BenchmarkConfiguration.outputTimeUnit.<get-outputTimeUnit>|<get-outputTimeUnit>(){}[0]
    final val warmups // kotlinx.benchmark/BenchmarkConfiguration.warmups|{}warmups[0]
        final fun <get-warmups>(): kotlin/Int // kotlinx.benchmark/BenchmarkConfiguration.warmups.<get-warmups>|<get-warmups>(){}[0]
}
final class kotlinx.benchmark/ConsoleBenchmarkProgress : kotlinx.benchmark/BenchmarkProgress { // kotlinx.benchmark/ConsoleBenchmarkProgress|null[0]
    constructor <init>() // kotlinx.benchmark/ConsoleBenchmarkProgress.<init>|<init>(){}[0]
    final fun endBenchmark(kotlin/String, kotlin/String, kotlinx.benchmark/BenchmarkProgress.FinishStatus, kotlin/String) // kotlinx.benchmark/ConsoleBenchmarkProgress.endBenchmark|endBenchmark(kotlin.String;kotlin.String;kotlinx.benchmark.BenchmarkProgress.FinishStatus;kotlin.String){}[0]
    final fun endBenchmarkException(kotlin/String, kotlin/String, kotlin/String, kotlin/String) // kotlinx.benchmark/ConsoleBenchmarkProgress.endBenchmarkException|endBenchmarkException(kotlin.String;kotlin.String;kotlin.String;kotlin.String){}[0]
    final fun endSuite(kotlin/String, kotlin/String) // kotlinx.benchmark/ConsoleBenchmarkProgress.endSuite|endSuite(kotlin.String;kotlin.String){}[0]
    final fun output(kotlin/String, kotlin/String, kotlin/String) // kotlinx.benchmark/ConsoleBenchmarkProgress.output|output(kotlin.String;kotlin.String;kotlin.String){}[0]
    final fun startBenchmark(kotlin/String, kotlin/String) // kotlinx.benchmark/ConsoleBenchmarkProgress.startBenchmark|startBenchmark(kotlin.String;kotlin.String){}[0]
    final fun startSuite(kotlin/String) // kotlinx.benchmark/ConsoleBenchmarkProgress.startSuite|startSuite(kotlin.String){}[0]
}
final class kotlinx.benchmark/IterationTime { // kotlinx.benchmark/IterationTime|null[0]
    constructor <init>(kotlin/Long, kotlinx.benchmark/BenchmarkTimeUnit) // kotlinx.benchmark/IterationTime.<init>|<init>(kotlin.Long;kotlinx.benchmark.BenchmarkTimeUnit){}[0]
    final fun component1(): kotlin/Long // kotlinx.benchmark/IterationTime.component1|component1(){}[0]
    final fun component2(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/IterationTime.component2|component2(){}[0]
    final fun copy(kotlin/Long =..., kotlinx.benchmark/BenchmarkTimeUnit =...): kotlinx.benchmark/IterationTime // kotlinx.benchmark/IterationTime.copy|copy(kotlin.Long;kotlinx.benchmark.BenchmarkTimeUnit){}[0]
    final fun equals(kotlin/Any?): kotlin/Boolean // kotlinx.benchmark/IterationTime.equals|equals(kotlin.Any?){}[0]
    final fun hashCode(): kotlin/Int // kotlinx.benchmark/IterationTime.hashCode|hashCode(){}[0]
    final fun toString(): kotlin/String // kotlinx.benchmark/IterationTime.toString|toString(){}[0]
    final val timeUnit // kotlinx.benchmark/IterationTime.timeUnit|{}timeUnit[0]
        final fun <get-timeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/IterationTime.timeUnit.<get-timeUnit>|<get-timeUnit>(){}[0]
    final val value // kotlinx.benchmark/IterationTime.value|{}value[0]
        final fun <get-value>(): kotlin/Long // kotlinx.benchmark/IterationTime.value.<get-value>|<get-value>(){}[0]
}
final class kotlinx.benchmark/ReportBenchmarkResult { // kotlinx.benchmark/ReportBenchmarkResult|null[0]
    constructor <init>(kotlinx.benchmark/BenchmarkConfiguration, kotlinx.benchmark/BenchmarkDescriptor<*>, kotlin.collections/Map<kotlin/String, kotlin/String>, kotlin/Double, kotlin/Double, kotlin/Pair<kotlin/Double, kotlin/Double>, kotlin.collections/Map<kotlin/Double, kotlin/Double>, kotlin/DoubleArray) // kotlinx.benchmark/ReportBenchmarkResult.<init>|<init>(kotlinx.benchmark.BenchmarkConfiguration;kotlinx.benchmark.BenchmarkDescriptor<*>;kotlin.collections.Map<kotlin.String,kotlin.String>;kotlin.Double;kotlin.Double;kotlin.Pair<kotlin.Double,kotlin.Double>;kotlin.collections.Map<kotlin.Double,kotlin.Double>;kotlin.DoubleArray){}[0]
    final val benchmark // kotlinx.benchmark/ReportBenchmarkResult.benchmark|{}benchmark[0]
        final fun <get-benchmark>(): kotlinx.benchmark/BenchmarkDescriptor<*> // kotlinx.benchmark/ReportBenchmarkResult.benchmark.<get-benchmark>|<get-benchmark>(){}[0]
    final val confidence // kotlinx.benchmark/ReportBenchmarkResult.confidence|{}confidence[0]
        final fun <get-confidence>(): kotlin/Pair<kotlin/Double, kotlin/Double> // kotlinx.benchmark/ReportBenchmarkResult.confidence.<get-confidence>|<get-confidence>(){}[0]
    final val config // kotlinx.benchmark/ReportBenchmarkResult.config|{}config[0]
        final fun <get-config>(): kotlinx.benchmark/BenchmarkConfiguration // kotlinx.benchmark/ReportBenchmarkResult.config.<get-config>|<get-config>(){}[0]
    final val error // kotlinx.benchmark/ReportBenchmarkResult.error|{}error[0]
        final fun <get-error>(): kotlin/Double // kotlinx.benchmark/ReportBenchmarkResult.error.<get-error>|<get-error>(){}[0]
    final val params // kotlinx.benchmark/ReportBenchmarkResult.params|{}params[0]
        final fun <get-params>(): kotlin.collections/Map<kotlin/String, kotlin/String> // kotlinx.benchmark/ReportBenchmarkResult.params.<get-params>|<get-params>(){}[0]
    final val percentiles // kotlinx.benchmark/ReportBenchmarkResult.percentiles|{}percentiles[0]
        final fun <get-percentiles>(): kotlin.collections/Map<kotlin/Double, kotlin/Double> // kotlinx.benchmark/ReportBenchmarkResult.percentiles.<get-percentiles>|<get-percentiles>(){}[0]
    final val score // kotlinx.benchmark/ReportBenchmarkResult.score|{}score[0]
        final fun <get-score>(): kotlin/Double // kotlinx.benchmark/ReportBenchmarkResult.score.<get-score>|<get-score>(){}[0]
    final val values // kotlinx.benchmark/ReportBenchmarkResult.values|{}values[0]
        final fun <get-values>(): kotlin/DoubleArray // kotlinx.benchmark/ReportBenchmarkResult.values.<get-values>|<get-values>(){}[0]
}
final class kotlinx.benchmark/ReportBenchmarksStatistics { // kotlinx.benchmark/ReportBenchmarksStatistics|null[0]
    constructor <init>(kotlin/DoubleArray) // kotlinx.benchmark/ReportBenchmarksStatistics.<init>|<init>(kotlin.DoubleArray){}[0]
    final fun max(): kotlin/Double // kotlinx.benchmark/ReportBenchmarksStatistics.max|max(){}[0]
    final fun mean(): kotlin/Double // kotlinx.benchmark/ReportBenchmarksStatistics.mean|mean(){}[0]
    final fun median(): kotlin/Double // kotlinx.benchmark/ReportBenchmarksStatistics.median|median(){}[0]
    final fun min(): kotlin/Double // kotlinx.benchmark/ReportBenchmarksStatistics.min|min(){}[0]
    final fun standardDeviation(): kotlin/Double // kotlinx.benchmark/ReportBenchmarksStatistics.standardDeviation|standardDeviation(){}[0]
    final fun valueAt(kotlin/Double): kotlin/Double // kotlinx.benchmark/ReportBenchmarksStatistics.valueAt|valueAt(kotlin.Double){}[0]
    final object Companion { // kotlinx.benchmark/ReportBenchmarksStatistics.Companion|null[0]
        final fun createResult(kotlinx.benchmark/BenchmarkDescriptor<*>, kotlin.collections/Map<kotlin/String, kotlin/String>, kotlinx.benchmark/BenchmarkConfiguration, kotlin/DoubleArray): kotlinx.benchmark/ReportBenchmarkResult // kotlinx.benchmark/ReportBenchmarksStatistics.Companion.createResult|createResult(kotlinx.benchmark.BenchmarkDescriptor<*>;kotlin.collections.Map<kotlin.String,kotlin.String>;kotlinx.benchmark.BenchmarkConfiguration;kotlin.DoubleArray){}[0]
    }
    final val size // kotlinx.benchmark/ReportBenchmarksStatistics.size|{}size[0]
        final fun <get-size>(): kotlin/Int // kotlinx.benchmark/ReportBenchmarksStatistics.size.<get-size>|<get-size>(){}[0]
    final val values // kotlinx.benchmark/ReportBenchmarksStatistics.values|{}values[0]
        final fun <get-values>(): kotlin/DoubleArray // kotlinx.benchmark/ReportBenchmarksStatistics.values.<get-values>|<get-values>(){}[0]
}
final class kotlinx.benchmark/RunnerConfiguration { // kotlinx.benchmark/RunnerConfiguration|null[0]
    constructor <init>(kotlin/String) // kotlinx.benchmark/RunnerConfiguration.<init>|<init>(kotlin.String){}[0]
    final fun toString(): kotlin/String // kotlinx.benchmark/RunnerConfiguration.toString|toString(){}[0]
    final val advanced // kotlinx.benchmark/RunnerConfiguration.advanced|{}advanced[0]
        final fun <get-advanced>(): kotlin.collections/Map<kotlin/String, kotlin/String> // kotlinx.benchmark/RunnerConfiguration.advanced.<get-advanced>|<get-advanced>(){}[0]
    final val exclude // kotlinx.benchmark/RunnerConfiguration.exclude|{}exclude[0]
        final fun <get-exclude>(): kotlin.collections/List<kotlin/String> // kotlinx.benchmark/RunnerConfiguration.exclude.<get-exclude>|<get-exclude>(){}[0]
    final val include // kotlinx.benchmark/RunnerConfiguration.include|{}include[0]
        final fun <get-include>(): kotlin.collections/List<kotlin/String> // kotlinx.benchmark/RunnerConfiguration.include.<get-include>|<get-include>(){}[0]
    final val iterationTime // kotlinx.benchmark/RunnerConfiguration.iterationTime|{}iterationTime[0]
        final fun <get-iterationTime>(): kotlin/Long? // kotlinx.benchmark/RunnerConfiguration.iterationTime.<get-iterationTime>|<get-iterationTime>(){}[0]
    final val iterationTimeUnit // kotlinx.benchmark/RunnerConfiguration.iterationTimeUnit|{}iterationTimeUnit[0]
        final fun <get-iterationTimeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit? // kotlinx.benchmark/RunnerConfiguration.iterationTimeUnit.<get-iterationTimeUnit>|<get-iterationTimeUnit>(){}[0]
    final val iterations // kotlinx.benchmark/RunnerConfiguration.iterations|{}iterations[0]
        final fun <get-iterations>(): kotlin/Int? // kotlinx.benchmark/RunnerConfiguration.iterations.<get-iterations>|<get-iterations>(){}[0]
    final val mode // kotlinx.benchmark/RunnerConfiguration.mode|{}mode[0]
        final fun <get-mode>(): kotlinx.benchmark/Mode? // kotlinx.benchmark/RunnerConfiguration.mode.<get-mode>|<get-mode>(){}[0]
    final val name // kotlinx.benchmark/RunnerConfiguration.name|{}name[0]
        final fun <get-name>(): kotlin/String // kotlinx.benchmark/RunnerConfiguration.name.<get-name>|<get-name>(){}[0]
    final val outputTimeUnit // kotlinx.benchmark/RunnerConfiguration.outputTimeUnit|{}outputTimeUnit[0]
        final fun <get-outputTimeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit? // kotlinx.benchmark/RunnerConfiguration.outputTimeUnit.<get-outputTimeUnit>|<get-outputTimeUnit>(){}[0]
    final val params // kotlinx.benchmark/RunnerConfiguration.params|{}params[0]
        final fun <get-params>(): kotlin.collections/Map<kotlin/String, kotlin.collections/List<kotlin/String>> // kotlinx.benchmark/RunnerConfiguration.params.<get-params>|<get-params>(){}[0]
    final val reportFile // kotlinx.benchmark/RunnerConfiguration.reportFile|{}reportFile[0]
        final fun <get-reportFile>(): kotlin/String // kotlinx.benchmark/RunnerConfiguration.reportFile.<get-reportFile>|<get-reportFile>(){}[0]
    final val reportFormat // kotlinx.benchmark/RunnerConfiguration.reportFormat|{}reportFormat[0]
        final fun <get-reportFormat>(): kotlin/String // kotlinx.benchmark/RunnerConfiguration.reportFormat.<get-reportFormat>|<get-reportFormat>(){}[0]
    final val traceFormat // kotlinx.benchmark/RunnerConfiguration.traceFormat|{}traceFormat[0]
        final fun <get-traceFormat>(): kotlin/String // kotlinx.benchmark/RunnerConfiguration.traceFormat.<get-traceFormat>|<get-traceFormat>(){}[0]
    final val warmups // kotlinx.benchmark/RunnerConfiguration.warmups|{}warmups[0]
        final fun <get-warmups>(): kotlin/Int? // kotlinx.benchmark/RunnerConfiguration.warmups.<get-warmups>|<get-warmups>(){}[0]
}
final enum class kotlinx.benchmark/BenchmarkTimeUnit : kotlin/Enum<kotlinx.benchmark/BenchmarkTimeUnit> { // kotlinx.benchmark/BenchmarkTimeUnit|null[0]
    enum entry MICROSECONDS // kotlinx.benchmark/BenchmarkTimeUnit.MICROSECONDS|null[0]
    enum entry MILLISECONDS // kotlinx.benchmark/BenchmarkTimeUnit.MILLISECONDS|null[0]
    enum entry MINUTES // kotlinx.benchmark/BenchmarkTimeUnit.MINUTES|null[0]
    enum entry NANOSECONDS // kotlinx.benchmark/BenchmarkTimeUnit.NANOSECONDS|null[0]
    enum entry SECONDS // kotlinx.benchmark/BenchmarkTimeUnit.SECONDS|null[0]
    final fun valueOf(kotlin/String): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/BenchmarkTimeUnit.valueOf|valueOf#static(kotlin.String){}[0]
    final fun values(): kotlin/Array<kotlinx.benchmark/BenchmarkTimeUnit> // kotlinx.benchmark/BenchmarkTimeUnit.values|values#static(){}[0]
    final val entries // kotlinx.benchmark/BenchmarkTimeUnit.entries|#static{}entries[0]
        final fun <get-entries>(): kotlin.enums/EnumEntries<kotlinx.benchmark/BenchmarkTimeUnit> // kotlinx.benchmark/BenchmarkTimeUnit.entries.<get-entries>|<get-entries>#static(){}[0]
}
final enum class kotlinx.benchmark/Mode : kotlin/Enum<kotlinx.benchmark/Mode> { // kotlinx.benchmark/Mode|null[0]
    enum entry AverageTime // kotlinx.benchmark/Mode.AverageTime|null[0]
    enum entry Throughput // kotlinx.benchmark/Mode.Throughput|null[0]
    final fun valueOf(kotlin/String): kotlinx.benchmark/Mode // kotlinx.benchmark/Mode.valueOf|valueOf#static(kotlin.String){}[0]
    final fun values(): kotlin/Array<kotlinx.benchmark/Mode> // kotlinx.benchmark/Mode.values|values#static(){}[0]
    final val entries // kotlinx.benchmark/Mode.entries|#static{}entries[0]
        final fun <get-entries>(): kotlin.enums/EnumEntries<kotlinx.benchmark/Mode> // kotlinx.benchmark/Mode.entries.<get-entries>|<get-entries>#static(){}[0]
}
final enum class kotlinx.benchmark/Scope : kotlin/Enum<kotlinx.benchmark/Scope> { // kotlinx.benchmark/Scope|null[0]
    enum entry Benchmark // kotlinx.benchmark/Scope.Benchmark|null[0]
    final fun valueOf(kotlin/String): kotlinx.benchmark/Scope // kotlinx.benchmark/Scope.valueOf|valueOf#static(kotlin.String){}[0]
    final fun values(): kotlin/Array<kotlinx.benchmark/Scope> // kotlinx.benchmark/Scope.values|values#static(){}[0]
    final val entries // kotlinx.benchmark/Scope.entries|#static{}entries[0]
        final fun <get-entries>(): kotlin.enums/EnumEntries<kotlinx.benchmark/Scope> // kotlinx.benchmark/Scope.entries.<get-entries>|<get-entries>#static(){}[0]
}
final fun (kotlin/Double).kotlinx.benchmark/formatSignificant(kotlin/Int): kotlin/String // kotlinx.benchmark/formatSignificant|formatSignificant@kotlin.Double(kotlin.Int){}[0]
final fun (kotlin/Double).kotlinx.benchmark/isApproximateZero(): kotlin/Boolean // kotlinx.benchmark/isApproximateZero|isApproximateZero@kotlin.Double(){}[0]
final fun (kotlin/Double).kotlinx.benchmark/isNaNOrZero(): kotlin/Boolean // kotlinx.benchmark/isNaNOrZero|isNaNOrZero@kotlin.Double(){}[0]
final fun (kotlin/Double).kotlinx.benchmark/nanosToSample(kotlinx.benchmark/Mode, kotlinx.benchmark/BenchmarkTimeUnit): kotlin/Double // kotlinx.benchmark/nanosToSample|nanosToSample@kotlin.Double(kotlinx.benchmark.Mode;kotlinx.benchmark.BenchmarkTimeUnit){}[0]
final fun (kotlin/Double).kotlinx.benchmark/nanosToText(kotlinx.benchmark/Mode, kotlinx.benchmark/BenchmarkTimeUnit): kotlin/String // kotlinx.benchmark/nanosToText|nanosToText@kotlin.Double(kotlinx.benchmark.Mode;kotlinx.benchmark.BenchmarkTimeUnit){}[0]
final fun (kotlin/Double).kotlinx.benchmark/sampleToText(kotlinx.benchmark/Mode, kotlinx.benchmark/BenchmarkTimeUnit): kotlin/String // kotlinx.benchmark/sampleToText|sampleToText@kotlin.Double(kotlinx.benchmark.Mode;kotlinx.benchmark.BenchmarkTimeUnit){}[0]
final fun (kotlin/String).kotlinx.benchmark/toMode(): kotlinx.benchmark/Mode // kotlinx.benchmark/toMode|toMode@kotlin.String(){}[0]
final fun (kotlinx.benchmark/BenchmarkTimeUnit).kotlinx.benchmark/toMultiplier(): kotlin/Long // kotlinx.benchmark/toMultiplier|toMultiplier@kotlinx.benchmark.BenchmarkTimeUnit(){}[0]
final fun (kotlinx.benchmark/BenchmarkTimeUnit).kotlinx.benchmark/toSecondsMultiplier(): kotlin/Double // kotlinx.benchmark/toSecondsMultiplier|toSecondsMultiplier@kotlinx.benchmark.BenchmarkTimeUnit(){}[0]
final fun (kotlinx.benchmark/BenchmarkTimeUnit).kotlinx.benchmark/toText(): kotlin/String // kotlinx.benchmark/toText|toText@kotlinx.benchmark.BenchmarkTimeUnit(){}[0]
final fun (kotlinx.benchmark/Blackhole).kotlinx.benchmark/flush() // kotlinx.benchmark/flush|flush@kotlinx.benchmark.Blackhole(){}[0]
final fun (kotlinx.benchmark/Mode).kotlinx.benchmark/toText(): kotlin/String // kotlinx.benchmark/toText|toText@kotlinx.benchmark.Mode(){}[0]
final fun kotlinx.benchmark/runWithParameters(kotlin.collections/List<kotlin/String>, kotlin.collections/Map<kotlin/String, kotlin.collections/List<kotlin/String>>, kotlin.collections/Map<kotlin/String, kotlin.collections/List<kotlin/String>>, kotlin/Function1<kotlin.collections/Map<kotlin/String, kotlin/String>, kotlin/Unit>) // kotlinx.benchmark/runWithParameters|runWithParameters(kotlin.collections.List<kotlin.String>;kotlin.collections.Map<kotlin.String,kotlin.collections.List<kotlin.String>>;kotlin.collections.Map<kotlin.String,kotlin.collections.List<kotlin.String>>;kotlin.Function1<kotlin.collections.Map<kotlin.String,kotlin.String>,kotlin.Unit>){}[0]
final fun kotlinx.benchmark/unitText(kotlinx.benchmark/Mode, kotlinx.benchmark/BenchmarkTimeUnit): kotlin/String // kotlinx.benchmark/unitText|unitText(kotlinx.benchmark.Mode;kotlinx.benchmark.BenchmarkTimeUnit){}[0]
final object kotlinx.benchmark/DefaultDescriptorParameters { // kotlinx.benchmark/DefaultDescriptorParameters|null[0]
    final val iterationTime // kotlinx.benchmark/DefaultDescriptorParameters.iterationTime|{}iterationTime[0]
        final fun <get-iterationTime>(): kotlinx.benchmark/IterationTime // kotlinx.benchmark/DefaultDescriptorParameters.iterationTime.<get-iterationTime>|<get-iterationTime>(){}[0]
    final val iterations // kotlinx.benchmark/DefaultDescriptorParameters.iterations|{}iterations[0]
        final fun <get-iterations>(): kotlin/Int // kotlinx.benchmark/DefaultDescriptorParameters.iterations.<get-iterations>|<get-iterations>(){}[0]
    final val mode // kotlinx.benchmark/DefaultDescriptorParameters.mode|{}mode[0]
        final fun <get-mode>(): kotlinx.benchmark/Mode // kotlinx.benchmark/DefaultDescriptorParameters.mode.<get-mode>|<get-mode>(){}[0]
    final val outputTimeUnit // kotlinx.benchmark/DefaultDescriptorParameters.outputTimeUnit|{}outputTimeUnit[0]
        final fun <get-outputTimeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/DefaultDescriptorParameters.outputTimeUnit.<get-outputTimeUnit>|<get-outputTimeUnit>(){}[0]
    final val warmups // kotlinx.benchmark/DefaultDescriptorParameters.warmups|{}warmups[0]
        final fun <get-warmups>(): kotlin/Int // kotlinx.benchmark/DefaultDescriptorParameters.warmups.<get-warmups>|<get-warmups>(){}[0]
}
open annotation class kotlinx.benchmark/Benchmark : kotlin/Annotation { // kotlinx.benchmark/Benchmark|null[0]
    constructor <init>() // kotlinx.benchmark/Benchmark.<init>|<init>(){}[0]
}
open annotation class kotlinx.benchmark/BenchmarkMode : kotlin/Annotation { // kotlinx.benchmark/BenchmarkMode|null[0]
    constructor <init>(kotlin/Array<out kotlinx.benchmark/Mode>...) // kotlinx.benchmark/BenchmarkMode.<init>|<init>(kotlin.Array<out|kotlinx.benchmark.Mode>...){}[0]
    final val value // kotlinx.benchmark/BenchmarkMode.value|{}value[0]
        final fun <get-value>(): kotlin/Array<out kotlinx.benchmark/Mode> // kotlinx.benchmark/BenchmarkMode.value.<get-value>|<get-value>(){}[0]
}
open annotation class kotlinx.benchmark/Measurement : kotlin/Annotation { // kotlinx.benchmark/Measurement|null[0]
    constructor <init>(kotlin/Int =..., kotlin/Int =..., kotlinx.benchmark/BenchmarkTimeUnit =..., kotlin/Int =...) // kotlinx.benchmark/Measurement.<init>|<init>(kotlin.Int;kotlin.Int;kotlinx.benchmark.BenchmarkTimeUnit;kotlin.Int){}[0]
    final val batchSize // kotlinx.benchmark/Measurement.batchSize|{}batchSize[0]
        final fun <get-batchSize>(): kotlin/Int // kotlinx.benchmark/Measurement.batchSize.<get-batchSize>|<get-batchSize>(){}[0]
    final val iterations // kotlinx.benchmark/Measurement.iterations|{}iterations[0]
        final fun <get-iterations>(): kotlin/Int // kotlinx.benchmark/Measurement.iterations.<get-iterations>|<get-iterations>(){}[0]
    final val time // kotlinx.benchmark/Measurement.time|{}time[0]
        final fun <get-time>(): kotlin/Int // kotlinx.benchmark/Measurement.time.<get-time>|<get-time>(){}[0]
    final val timeUnit // kotlinx.benchmark/Measurement.timeUnit|{}timeUnit[0]
        final fun <get-timeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/Measurement.timeUnit.<get-timeUnit>|<get-timeUnit>(){}[0]
}
open annotation class kotlinx.benchmark/OutputTimeUnit : kotlin/Annotation { // kotlinx.benchmark/OutputTimeUnit|null[0]
    constructor <init>(kotlinx.benchmark/BenchmarkTimeUnit) // kotlinx.benchmark/OutputTimeUnit.<init>|<init>(kotlinx.benchmark.BenchmarkTimeUnit){}[0]
    final val value // kotlinx.benchmark/OutputTimeUnit.value|{}value[0]
        final fun <get-value>(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/OutputTimeUnit.value.<get-value>|<get-value>(){}[0]
}
open annotation class kotlinx.benchmark/Param : kotlin/Annotation { // kotlinx.benchmark/Param|null[0]
    constructor <init>(kotlin/Array<out kotlin/String>...) // kotlinx.benchmark/Param.<init>|<init>(kotlin.Array<out|kotlin.String>...){}[0]
    final val value // kotlinx.benchmark/Param.value|{}value[0]
        final fun <get-value>(): kotlin/Array<out kotlin/String> // kotlinx.benchmark/Param.value.<get-value>|<get-value>(){}[0]
}
open annotation class kotlinx.benchmark/Setup : kotlin/Annotation { // kotlinx.benchmark/Setup|null[0]
    constructor <init>() // kotlinx.benchmark/Setup.<init>|<init>(){}[0]
}
open annotation class kotlinx.benchmark/State : kotlin/Annotation { // kotlinx.benchmark/State|null[0]
    constructor <init>(kotlinx.benchmark/Scope) // kotlinx.benchmark/State.<init>|<init>(kotlinx.benchmark.Scope){}[0]
    final val value // kotlinx.benchmark/State.value|{}value[0]
        final fun <get-value>(): kotlinx.benchmark/Scope // kotlinx.benchmark/State.value.<get-value>|<get-value>(){}[0]
}
open annotation class kotlinx.benchmark/TearDown : kotlin/Annotation { // kotlinx.benchmark/TearDown|null[0]
    constructor <init>() // kotlinx.benchmark/TearDown.<init>|<init>(){}[0]
}
open annotation class kotlinx.benchmark/Warmup : kotlin/Annotation { // kotlinx.benchmark/Warmup|null[0]
    constructor <init>(kotlin/Int =..., kotlin/Int =..., kotlinx.benchmark/BenchmarkTimeUnit =..., kotlin/Int =...) // kotlinx.benchmark/Warmup.<init>|<init>(kotlin.Int;kotlin.Int;kotlinx.benchmark.BenchmarkTimeUnit;kotlin.Int){}[0]
    final val batchSize // kotlinx.benchmark/Warmup.batchSize|{}batchSize[0]
        final fun <get-batchSize>(): kotlin/Int // kotlinx.benchmark/Warmup.batchSize.<get-batchSize>|<get-batchSize>(){}[0]
    final val iterations // kotlinx.benchmark/Warmup.iterations|{}iterations[0]
        final fun <get-iterations>(): kotlin/Int // kotlinx.benchmark/Warmup.iterations.<get-iterations>|<get-iterations>(){}[0]
    final val time // kotlinx.benchmark/Warmup.time|{}time[0]
        final fun <get-time>(): kotlin/Int // kotlinx.benchmark/Warmup.time.<get-time>|<get-time>(){}[0]
    final val timeUnit // kotlinx.benchmark/Warmup.timeUnit|{}timeUnit[0]
        final fun <get-timeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/Warmup.timeUnit.<get-timeUnit>|<get-timeUnit>(){}[0]
}
open class <#A: kotlin/Any?> kotlinx.benchmark/BenchmarkDescriptorWithBlackholeParameter : kotlinx.benchmark/BenchmarkDescriptor<#A> { // kotlinx.benchmark/BenchmarkDescriptorWithBlackholeParameter|null[0]
    constructor <init>(kotlin/String, kotlinx.benchmark/SuiteDescriptor<#A>, kotlinx.benchmark/Blackhole, kotlin/Function2<#A, kotlinx.benchmark/Blackhole, kotlin/Any?>) // kotlinx.benchmark/BenchmarkDescriptorWithBlackholeParameter.<init>|<init>(kotlin.String;kotlinx.benchmark.SuiteDescriptor<1:0>;kotlinx.benchmark.Blackhole;kotlin.Function2<1:0,kotlinx.benchmark.Blackhole,kotlin.Any?>){}[0]
    final val function // kotlinx.benchmark/BenchmarkDescriptorWithBlackholeParameter.function|{}function[0]
        final fun <get-function>(): kotlin/Function2<#A, kotlinx.benchmark/Blackhole, kotlin/Any?> // kotlinx.benchmark/BenchmarkDescriptorWithBlackholeParameter.function.<get-function>|<get-function>(){}[0]
}
open class <#A: kotlin/Any?> kotlinx.benchmark/BenchmarkDescriptorWithNoBlackholeParameter : kotlinx.benchmark/BenchmarkDescriptor<#A> { // kotlinx.benchmark/BenchmarkDescriptorWithNoBlackholeParameter|null[0]
    constructor <init>(kotlin/String, kotlinx.benchmark/SuiteDescriptor<#A>, kotlinx.benchmark/Blackhole, kotlin/Function1<#A, kotlin/Any?>) // kotlinx.benchmark/BenchmarkDescriptorWithNoBlackholeParameter.<init>|<init>(kotlin.String;kotlinx.benchmark.SuiteDescriptor<1:0>;kotlinx.benchmark.Blackhole;kotlin.Function1<1:0,kotlin.Any?>){}[0]
    final val function // kotlinx.benchmark/BenchmarkDescriptorWithNoBlackholeParameter.function|{}function[0]
        final fun <get-function>(): kotlin/Function1<#A, kotlin/Any?> // kotlinx.benchmark/BenchmarkDescriptorWithNoBlackholeParameter.function.<get-function>|<get-function>(){}[0]
}
open class <#A: kotlin/Any?> kotlinx.benchmark/SuiteDescriptor { // kotlinx.benchmark/SuiteDescriptor|null[0]
    constructor <init>(kotlin/String, kotlin/Function0<#A>, kotlin/Function2<#A, kotlin.collections/Map<kotlin/String, kotlin/String>, kotlin/Unit>, kotlin/Function1<#A, kotlin/Unit>, kotlin/Function1<#A, kotlin/Unit>, kotlin.collections/List<kotlin/String>, kotlin.collections/Map<kotlin/String, kotlin.collections/List<kotlin/String>>, kotlin/Int =..., kotlin/Int =..., kotlinx.benchmark/IterationTime =..., kotlinx.benchmark/BenchmarkTimeUnit =..., kotlinx.benchmark/Mode =...) // kotlinx.benchmark/SuiteDescriptor.<init>|<init>(kotlin.String;kotlin.Function0<1:0>;kotlin.Function2<1:0,kotlin.collections.Map<kotlin.String,kotlin.String>,kotlin.Unit>;kotlin.Function1<1:0,kotlin.Unit>;kotlin.Function1<1:0,kotlin.Unit>;kotlin.collections.List<kotlin.String>;kotlin.collections.Map<kotlin.String,kotlin.collections.List<kotlin.String>>;kotlin.Int;kotlin.Int;kotlinx.benchmark.IterationTime;kotlinx.benchmark.BenchmarkTimeUnit;kotlinx.benchmark.Mode){}[0]
    final fun add(kotlinx.benchmark/BenchmarkDescriptor<#A>) // kotlinx.benchmark/SuiteDescriptor.add|add(kotlinx.benchmark.BenchmarkDescriptor<1:0>){}[0]
    final val benchmarks // kotlinx.benchmark/SuiteDescriptor.benchmarks|{}benchmarks[0]
        final fun <get-benchmarks>(): kotlin.collections/List<kotlinx.benchmark/BenchmarkDescriptor<#A>> // kotlinx.benchmark/SuiteDescriptor.benchmarks.<get-benchmarks>|<get-benchmarks>(){}[0]
    final val defaultParameters // kotlinx.benchmark/SuiteDescriptor.defaultParameters|{}defaultParameters[0]
        final fun <get-defaultParameters>(): kotlin.collections/Map<kotlin/String, kotlin.collections/List<kotlin/String>> // kotlinx.benchmark/SuiteDescriptor.defaultParameters.<get-defaultParameters>|<get-defaultParameters>(){}[0]
    final val factory // kotlinx.benchmark/SuiteDescriptor.factory|{}factory[0]
        final fun <get-factory>(): kotlin/Function0<#A> // kotlinx.benchmark/SuiteDescriptor.factory.<get-factory>|<get-factory>(){}[0]
    final val iterationTime // kotlinx.benchmark/SuiteDescriptor.iterationTime|{}iterationTime[0]
        final fun <get-iterationTime>(): kotlinx.benchmark/IterationTime // kotlinx.benchmark/SuiteDescriptor.iterationTime.<get-iterationTime>|<get-iterationTime>(){}[0]
    final val iterations // kotlinx.benchmark/SuiteDescriptor.iterations|{}iterations[0]
        final fun <get-iterations>(): kotlin/Int // kotlinx.benchmark/SuiteDescriptor.iterations.<get-iterations>|<get-iterations>(){}[0]
    final val mode // kotlinx.benchmark/SuiteDescriptor.mode|{}mode[0]
        final fun <get-mode>(): kotlinx.benchmark/Mode // kotlinx.benchmark/SuiteDescriptor.mode.<get-mode>|<get-mode>(){}[0]
    final val name // kotlinx.benchmark/SuiteDescriptor.name|{}name[0]
        final fun <get-name>(): kotlin/String // kotlinx.benchmark/SuiteDescriptor.name.<get-name>|<get-name>(){}[0]
    final val outputTimeUnit // kotlinx.benchmark/SuiteDescriptor.outputTimeUnit|{}outputTimeUnit[0]
        final fun <get-outputTimeUnit>(): kotlinx.benchmark/BenchmarkTimeUnit // kotlinx.benchmark/SuiteDescriptor.outputTimeUnit.<get-outputTimeUnit>|<get-outputTimeUnit>(){}[0]
    final val parameters // kotlinx.benchmark/SuiteDescriptor.parameters|{}parameters[0]
        final fun <get-parameters>(): kotlin.collections/List<kotlin/String> // kotlinx.benchmark/SuiteDescriptor.parameters.<get-parameters>|<get-parameters>(){}[0]
    final val parametrize // kotlinx.benchmark/SuiteDescriptor.parametrize|{}parametrize[0]
        final fun <get-parametrize>(): kotlin/Function2<#A, kotlin.collections/Map<kotlin/String, kotlin/String>, kotlin/Unit> // kotlinx.benchmark/SuiteDescriptor.parametrize.<get-parametrize>|<get-parametrize>(){}[0]
    final val setup // kotlinx.benchmark/SuiteDescriptor.setup|{}setup[0]
        final fun <get-setup>(): kotlin/Function1<#A, kotlin/Unit> // kotlinx.benchmark/SuiteDescriptor.setup.<get-setup>|<get-setup>(){}[0]
    final val teardown // kotlinx.benchmark/SuiteDescriptor.teardown|{}teardown[0]
        final fun <get-teardown>(): kotlin/Function1<#A, kotlin/Unit> // kotlinx.benchmark/SuiteDescriptor.teardown.<get-teardown>|<get-teardown>(){}[0]
    final val warmups // kotlinx.benchmark/SuiteDescriptor.warmups|{}warmups[0]
        final fun <get-warmups>(): kotlin/Int // kotlinx.benchmark/SuiteDescriptor.warmups.<get-warmups>|<get-warmups>(){}[0]
}
open class kotlinx.benchmark/CommonBlackhole { // kotlinx.benchmark/CommonBlackhole|null[0]
    constructor <init>() // kotlinx.benchmark/CommonBlackhole.<init>|<init>(){}[0]
    final fun consume(kotlin/Any?) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Any?){}[0]
    final fun consume(kotlin/Boolean) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Boolean){}[0]
    final fun consume(kotlin/Byte) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Byte){}[0]
    final fun consume(kotlin/Char) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Char){}[0]
    final fun consume(kotlin/Double) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Double){}[0]
    final fun consume(kotlin/Float) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Float){}[0]
    final fun consume(kotlin/Int) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Int){}[0]
    final fun consume(kotlin/Long) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Long){}[0]
    final fun consume(kotlin/Short) // kotlinx.benchmark/CommonBlackhole.consume|consume(kotlin.Short){}[0]
    final fun flushMe() // kotlinx.benchmark/CommonBlackhole.flushMe|flushMe(){}[0]
}
open class kotlinx.benchmark/IntelliJBenchmarkProgress : kotlinx.benchmark/BenchmarkProgress { // kotlinx.benchmark/IntelliJBenchmarkProgress|null[0]
    constructor <init>() // kotlinx.benchmark/IntelliJBenchmarkProgress.<init>|<init>(){}[0]
    final var currentClass // kotlinx.benchmark/IntelliJBenchmarkProgress.currentClass|<get-currentClass>(){}[0]
        final fun <get-currentClass>(): kotlin/String // kotlinx.benchmark/IntelliJBenchmarkProgress.currentClass.<get-currentClass>|<get-currentClass>(){}[0]
        final fun <set-currentClass>(kotlin/String) // kotlinx.benchmark/IntelliJBenchmarkProgress.currentClass.<set-currentClass>|<set-currentClass>(kotlin.String){}[0]
    final var currentStatus // kotlinx.benchmark/IntelliJBenchmarkProgress.currentStatus|<set-currentStatus>(kotlinx.benchmark.BenchmarkProgress.FinishStatus){}[0]
        final fun <get-currentStatus>(): kotlinx.benchmark/BenchmarkProgress.FinishStatus // kotlinx.benchmark/IntelliJBenchmarkProgress.currentStatus.<get-currentStatus>|<get-currentStatus>(){}[0]
        final fun <set-currentStatus>(kotlinx.benchmark/BenchmarkProgress.FinishStatus) // kotlinx.benchmark/IntelliJBenchmarkProgress.currentStatus.<set-currentStatus>|<set-currentStatus>(kotlinx.benchmark.BenchmarkProgress.FinishStatus){}[0]
    final var suiteStatus // kotlinx.benchmark/IntelliJBenchmarkProgress.suiteStatus|<get-suiteStatus>(){}[0]
        final fun <get-suiteStatus>(): kotlinx.benchmark/BenchmarkProgress.FinishStatus // kotlinx.benchmark/IntelliJBenchmarkProgress.suiteStatus.<get-suiteStatus>|<get-suiteStatus>(){}[0]
        final fun <set-suiteStatus>(kotlinx.benchmark/BenchmarkProgress.FinishStatus) // kotlinx.benchmark/IntelliJBenchmarkProgress.suiteStatus.<set-suiteStatus>|<set-suiteStatus>(kotlinx.benchmark.BenchmarkProgress.FinishStatus){}[0]
    open fun endBenchmark(kotlin/String, kotlin/String, kotlinx.benchmark/BenchmarkProgress.FinishStatus, kotlin/String) // kotlinx.benchmark/IntelliJBenchmarkProgress.endBenchmark|endBenchmark(kotlin.String;kotlin.String;kotlinx.benchmark.BenchmarkProgress.FinishStatus;kotlin.String){}[0]
    open fun endBenchmarkException(kotlin/String, kotlin/String, kotlin/String, kotlin/String) // kotlinx.benchmark/IntelliJBenchmarkProgress.endBenchmarkException|endBenchmarkException(kotlin.String;kotlin.String;kotlin.String;kotlin.String){}[0]
    open fun endSuite(kotlin/String, kotlin/String) // kotlinx.benchmark/IntelliJBenchmarkProgress.endSuite|endSuite(kotlin.String;kotlin.String){}[0]
    open fun output(kotlin/String, kotlin/String, kotlin/String) // kotlinx.benchmark/IntelliJBenchmarkProgress.output|output(kotlin.String;kotlin.String;kotlin.String){}[0]
    open fun startBenchmark(kotlin/String, kotlin/String) // kotlinx.benchmark/IntelliJBenchmarkProgress.startBenchmark|startBenchmark(kotlin.String;kotlin.String){}[0]
    open fun startSuite(kotlin/String) // kotlinx.benchmark/IntelliJBenchmarkProgress.startSuite|startSuite(kotlin.String){}[0]
}
sealed class kotlinx.benchmark/BenchmarkReportFormatter { // kotlinx.benchmark/BenchmarkReportFormatter|null[0]
    abstract fun format(kotlin.collections/Collection<kotlinx.benchmark/ReportBenchmarkResult>): kotlin/String // kotlinx.benchmark/BenchmarkReportFormatter.format|format(kotlin.collections.Collection<kotlinx.benchmark.ReportBenchmarkResult>){}[0]
    constructor <init>() // kotlinx.benchmark/BenchmarkReportFormatter.<init>|<init>(){}[0]
    final object Companion { // kotlinx.benchmark/BenchmarkReportFormatter.Companion|null[0]
        final fun create(kotlin/String): kotlinx.benchmark/BenchmarkReportFormatter // kotlinx.benchmark/BenchmarkReportFormatter.Companion.create|create(kotlin.String){}[0]
    }
}
// Targets: [native]
final class kotlinx.benchmark.native/NativeExecutor : kotlinx.benchmark/SuiteExecutor { // kotlinx.benchmark.native/NativeExecutor|null[0]
    constructor <init>(kotlin/String, kotlin/Array<out kotlin/String>) // kotlinx.benchmark.native/NativeExecutor.<init>|<init>(kotlin.String;kotlin.Array<out|kotlin.String>){}[0]
    final class BenchmarkRun { // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun|null[0]
        constructor <init>(kotlin/String, kotlinx.benchmark/BenchmarkConfiguration, kotlin.collections/Map<kotlin/String, kotlin/String>) // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.<init>|<init>(kotlin.String;kotlinx.benchmark.BenchmarkConfiguration;kotlin.collections.Map<kotlin.String,kotlin.String>){}[0]
        final fun component1(): kotlin/String // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.component1|component1(){}[0]
        final fun component2(): kotlinx.benchmark/BenchmarkConfiguration // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.component2|component2(){}[0]
        final fun component3(): kotlin.collections/Map<kotlin/String, kotlin/String> // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.component3|component3(){}[0]
        final fun copy(kotlin/String =..., kotlinx.benchmark/BenchmarkConfiguration =..., kotlin.collections/Map<kotlin/String, kotlin/String> =...): kotlinx.benchmark.native/NativeExecutor.BenchmarkRun // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.copy|copy(kotlin.String;kotlinx.benchmark.BenchmarkConfiguration;kotlin.collections.Map<kotlin.String,kotlin.String>){}[0]
        final fun equals(kotlin/Any?): kotlin/Boolean // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.equals|equals(kotlin.Any?){}[0]
        final fun hashCode(): kotlin/Int // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.hashCode|hashCode(){}[0]
        final fun toString(): kotlin/String // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.toString|toString(){}[0]
        final val benchmarkName // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.benchmarkName|{}benchmarkName[0]
            final fun <get-benchmarkName>(): kotlin/String // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.benchmarkName.<get-benchmarkName>|<get-benchmarkName>(){}[0]
        final val config // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.config|{}config[0]
            final fun <get-config>(): kotlinx.benchmark/BenchmarkConfiguration // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.config.<get-config>|<get-config>(){}[0]
        final val parameters // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.parameters|{}parameters[0]
            final fun <get-parameters>(): kotlin.collections/Map<kotlin/String, kotlin/String> // kotlinx.benchmark.native/NativeExecutor.BenchmarkRun.parameters.<get-parameters>|<get-parameters>(){}[0]
    }
    final fun run(kotlinx.benchmark/BenchmarkDescriptor<kotlin/Any?>, kotlinx.benchmark.native/NativeExecutor.BenchmarkRun, kotlin/Int? =..., kotlin/Int? =...): kotlin/DoubleArray? // kotlinx.benchmark.native/NativeExecutor.run|run(kotlinx.benchmark.BenchmarkDescriptor<kotlin.Any?>;kotlinx.benchmark.native.NativeExecutor.BenchmarkRun;kotlin.Int?;kotlin.Int?){}[0]
    final fun run(kotlinx.benchmark/RunnerConfiguration, kotlin.collections/List<kotlinx.benchmark/BenchmarkDescriptor<kotlin/Any?>>, kotlin/Function0<kotlin/Unit>, kotlin/Function0<kotlin/Unit>) // kotlinx.benchmark.native/NativeExecutor.run|run(kotlinx.benchmark.RunnerConfiguration;kotlin.collections.List<kotlinx.benchmark.BenchmarkDescriptor<kotlin.Any?>>;kotlin.Function0<kotlin.Unit>;kotlin.Function0<kotlin.Unit>){}[0]
}
// Targets: [native]
final class kotlinx.benchmark/Blackhole { // kotlinx.benchmark/Blackhole|null[0]
    constructor <init>() // kotlinx.benchmark/Blackhole.<init>|<init>(){}[0]
    final inline fun consume(kotlin/Any?) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Any?){}[0]
    final inline fun consume(kotlin/Boolean) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Boolean){}[0]
    final inline fun consume(kotlin/Byte) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Byte){}[0]
    final inline fun consume(kotlin/Char) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Char){}[0]
    final inline fun consume(kotlin/Double) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Double){}[0]
    final inline fun consume(kotlin/Float) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Float){}[0]
    final inline fun consume(kotlin/Int) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Int){}[0]
    final inline fun consume(kotlin/Long) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Long){}[0]
    final inline fun consume(kotlin/Short) // kotlinx.benchmark/Blackhole.consume|consume(kotlin.Short){}[0]
    final var bh // kotlinx.benchmark/Blackhole.bh|{}bh[0]
        final fun <get-bh>(): kotlinx.benchmark/Blackhole? // kotlinx.benchmark/Blackhole.bh.<get-bh>|<get-bh>(){}[0]
        final fun <set-bh>(kotlinx.benchmark/Blackhole?) // kotlinx.benchmark/Blackhole.bh.<set-bh>|<set-bh>(kotlinx.benchmark.Blackhole?){}[0]
    final var d0 // kotlinx.benchmark/Blackhole.d0|{}d0[0]
        final fun <get-d0>(): kotlin/Double // kotlinx.benchmark/Blackhole.d0.<get-d0>|<get-d0>(){}[0]
        final fun <set-d0>(kotlin/Double) // kotlinx.benchmark/Blackhole.d0.<set-d0>|<set-d0>(kotlin.Double){}[0]
    final var d1 // kotlinx.benchmark/Blackhole.d1|{}d1[0]
        final fun <get-d1>(): kotlin/Double // kotlinx.benchmark/Blackhole.d1.<get-d1>|<get-d1>(){}[0]
        final fun <set-d1>(kotlin/Double) // kotlinx.benchmark/Blackhole.d1.<set-d1>|<set-d1>(kotlin.Double){}[0]
    final var f0 // kotlinx.benchmark/Blackhole.f0|{}f0[0]
        final fun <get-f0>(): kotlin/Float // kotlinx.benchmark/Blackhole.f0.<get-f0>|<get-f0>(){}[0]
        final fun <set-f0>(kotlin/Float) // kotlinx.benchmark/Blackhole.f0.<set-f0>|<set-f0>(kotlin.Float){}[0]
    final var f1 // kotlinx.benchmark/Blackhole.f1|{}f1[0]
        final fun <get-f1>(): kotlin/Float // kotlinx.benchmark/Blackhole.f1.<get-f1>|<get-f1>(){}[0]
        final fun <set-f1>(kotlin/Float) // kotlinx.benchmark/Blackhole.f1.<set-f1>|<set-f1>(kotlin.Float){}[0]
    final var i0 // kotlinx.benchmark/Blackhole.i0|{}i0[0]
        final fun <get-i0>(): kotlin/Int // kotlinx.benchmark/Blackhole.i0.<get-i0>|<get-i0>(){}[0]
        final fun <set-i0>(kotlin/Int) // kotlinx.benchmark/Blackhole.i0.<set-i0>|<set-i0>(kotlin.Int){}[0]
    final var i1 // kotlinx.benchmark/Blackhole.i1|{}i1[0]
        final fun <get-i1>(): kotlin/Int // kotlinx.benchmark/Blackhole.i1.<get-i1>|<get-i1>(){}[0]
        final fun <set-i1>(kotlin/Int) // kotlinx.benchmark/Blackhole.i1.<set-i1>|<set-i1>(kotlin.Int){}[0]
    final var l0 // kotlinx.benchmark/Blackhole.l0|{}l0[0]
        final fun <get-l0>(): kotlin/Long // kotlinx.benchmark/Blackhole.l0.<get-l0>|<get-l0>(){}[0]
        final fun <set-l0>(kotlin/Long) // kotlinx.benchmark/Blackhole.l0.<set-l0>|<set-l0>(kotlin.Long){}[0]
    final var l1 // kotlinx.benchmark/Blackhole.l1|{}l1[0]
        final fun <get-l1>(): kotlin/Long // kotlinx.benchmark/Blackhole.l1.<get-l1>|<get-l1>(){}[0]
        final fun <set-l1>(kotlin/Long) // kotlinx.benchmark/Blackhole.l1.<set-l1>|<set-l1>(kotlin.Long){}[0]
}
// Targets: [native]
final class kotlinx.benchmark/NativeIntelliJBenchmarkProgress : kotlinx.benchmark/IntelliJBenchmarkProgress { // kotlinx.benchmark/NativeIntelliJBenchmarkProgress|null[0]
    constructor <init>(kotlin/String) // kotlinx.benchmark/NativeIntelliJBenchmarkProgress.<init>|<init>(kotlin.String){}[0]
    final fun endBenchmarkException(kotlin/String, kotlin/String, kotlin/String, kotlin/String) // kotlinx.benchmark/NativeIntelliJBenchmarkProgress.endBenchmarkException|endBenchmarkException(kotlin.String;kotlin.String;kotlin.String;kotlin.String){}[0]
    final fun startBenchmark(kotlin/String, kotlin/String) // kotlinx.benchmark/NativeIntelliJBenchmarkProgress.startBenchmark|startBenchmark(kotlin.String;kotlin.String){}[0]
}
// Targets: [native]
final enum class kotlinx.benchmark/NativeFork : kotlin/Enum<kotlinx.benchmark/NativeFork> { // kotlinx.benchmark/NativeFork|null[0]
    enum entry PerBenchmark // kotlinx.benchmark/NativeFork.PerBenchmark|null[0]
    enum entry PerIteration // kotlinx.benchmark/NativeFork.PerIteration|null[0]
    final fun valueOf(kotlin/String): kotlinx.benchmark/NativeFork // kotlinx.benchmark/NativeFork.valueOf|valueOf#static(kotlin.String){}[0]
    final fun values(): kotlin/Array<kotlinx.benchmark/NativeFork> // kotlinx.benchmark/NativeFork.values|values#static(){}[0]
    final val entries // kotlinx.benchmark/NativeFork.entries|#static{}entries[0]
        final fun <get-entries>(): kotlin.enums/EnumEntries<kotlinx.benchmark/NativeFork> // kotlinx.benchmark/NativeFork.entries.<get-entries>|<get-entries>#static(){}[0]
}
// Targets: [js.jsIr, wasmJs]
final class kotlinx.benchmark/Blackhole : kotlinx.benchmark/CommonBlackhole { // kotlinx.benchmark/Blackhole|null[0]
    constructor <init>() // kotlinx.benchmark/Blackhole.<init>|<init>(){}[0]
}
// Targets: [js.jsIr]
final class <#A: kotlin/Any?> kotlinx.benchmark.js/JsBenchmarkDescriptorWithBlackholeParameter : kotlinx.benchmark/BenchmarkDescriptorWithBlackholeParameter<#A> { // kotlinx.benchmark.js/JsBenchmarkDescriptorWithBlackholeParameter|null[0]
    constructor <init>(kotlin/String, kotlinx.benchmark/SuiteDescriptor<#A>, kotlinx.benchmark/Blackhole, kotlin/Function2<#A, kotlinx.benchmark/Blackhole, kotlin.js/Promise<*>>) // kotlinx.benchmark.js/JsBenchmarkDescriptorWithBlackholeParameter.<init>|<init>(kotlin.String;kotlinx.benchmark.SuiteDescriptor<1:0>;kotlinx.benchmark.Blackhole;kotlin.Function2<1:0,kotlinx.benchmark.Blackhole,kotlin.js.Promise<*>>){}[0]
    constructor <init>(kotlin/String, kotlinx.benchmark/SuiteDescriptor<#A>, kotlinx.benchmark/Blackhole, kotlin/Function2<#A, kotlinx.benchmark/Blackhole, kotlin/Any?>, kotlin/Boolean =...) // kotlinx.benchmark.js/JsBenchmarkDescriptorWithBlackholeParameter.<init>|<init>(kotlin.String;kotlinx.benchmark.SuiteDescriptor<1:0>;kotlinx.benchmark.Blackhole;kotlin.Function2<1:0,kotlinx.benchmark.Blackhole,kotlin.Any?>;kotlin.Boolean){}[0]
    final val async // kotlinx.benchmark.js/JsBenchmarkDescriptorWithBlackholeParameter.async|{}async[0]
        final fun <get-async>(): kotlin/Boolean // kotlinx.benchmark.js/JsBenchmarkDescriptorWithBlackholeParameter.async.<get-async>|<get-async>(){}[0]
}
// Targets: [js.jsIr]
final class <#A: kotlin/Any?> kotlinx.benchmark.js/JsBenchmarkDescriptorWithNoBlackholeParameter : kotlinx.benchmark/BenchmarkDescriptorWithNoBlackholeParameter<#A> { // kotlinx.benchmark.js/JsBenchmarkDescriptorWithNoBlackholeParameter|null[0]
    constructor <init>(kotlin/String, kotlinx.benchmark/SuiteDescriptor<#A>, kotlinx.benchmark/Blackhole, kotlin/Function1<#A, kotlin.js/Promise<*>>) // kotlinx.benchmark.js/JsBenchmarkDescriptorWithNoBlackholeParameter.<init>|<init>(kotlin.String;kotlinx.benchmark.SuiteDescriptor<1:0>;kotlinx.benchmark.Blackhole;kotlin.Function1<1:0,kotlin.js.Promise<*>>){}[0]
    constructor <init>(kotlin/String, kotlinx.benchmark/SuiteDescriptor<#A>, kotlinx.benchmark/Blackhole, kotlin/Function1<#A, kotlin/Any?>, kotlin/Boolean =...) // kotlinx.benchmark.js/JsBenchmarkDescriptorWithNoBlackholeParameter.<init>|<init>(kotlin.String;kotlinx.benchmark.SuiteDescriptor<1:0>;kotlinx.benchmark.Blackhole;kotlin.Function1<1:0,kotlin.Any?>;kotlin.Boolean){}[0]
    final val async // kotlinx.benchmark.js/JsBenchmarkDescriptorWithNoBlackholeParameter.async|{}async[0]
        final fun <get-async>(): kotlin/Boolean // kotlinx.benchmark.js/JsBenchmarkDescriptorWithNoBlackholeParameter.async.<get-async>|<get-async>(){}[0]
}
// Targets: [js.jsIr]
final class kotlinx.benchmark.js/JsBenchmarkExecutor : kotlinx.benchmark/SuiteExecutor { // kotlinx.benchmark.js/JsBenchmarkExecutor|null[0]
    constructor <init>(kotlin/String, kotlin/Array<out kotlin/String>) // kotlinx.benchmark.js/JsBenchmarkExecutor.<init>|<init>(kotlin.String;kotlin.Array<out|kotlin.String>){}[0]
    final fun run(kotlinx.benchmark/RunnerConfiguration, kotlin.collections/List<kotlinx.benchmark/BenchmarkDescriptor<kotlin/Any?>>, kotlin/Function0<kotlin/Unit>, kotlin/Function0<kotlin/Unit>) // kotlinx.benchmark.js/JsBenchmarkExecutor.run|run(kotlinx.benchmark.RunnerConfiguration;kotlin.collections.List<kotlinx.benchmark.BenchmarkDescriptor<kotlin.Any?>>;kotlin.Function0<kotlin.Unit>;kotlin.Function0<kotlin.Unit>){}[0]
}
// Targets: [js.jsIr]
final class kotlinx.benchmark.js/JsBuiltInExecutor : kotlinx.benchmark/CommonSuiteExecutor { // kotlinx.benchmark.js/JsBuiltInExecutor|null[0]
    constructor <init>(kotlin/String, kotlin/Array<out kotlin/String>) // kotlinx.benchmark.js/JsBuiltInExecutor.<init>|<init>(kotlin.String;kotlin.Array<out|kotlin.String>){}[0]
    final fun run(kotlinx.benchmark/RunnerConfiguration, kotlin.collections/List<kotlinx.benchmark/BenchmarkDescriptor<kotlin/Any?>>, kotlin/Function0<kotlin/Unit>, kotlin/Function0<kotlin/Unit>) // kotlinx.benchmark.js/JsBuiltInExecutor.run|run(kotlinx.benchmark.RunnerConfiguration;kotlin.collections.List<kotlinx.benchmark.BenchmarkDescriptor<kotlin.Any?>>;kotlin.Function0<kotlin.Unit>;kotlin.Function0<kotlin.Unit>){}[0]
}
// Targets: [wasmJs]
final class kotlinx.benchmark.wasm/WasmBuiltInExecutor : kotlinx.benchmark/CommonSuiteExecutor { // kotlinx.benchmark.wasm/WasmBuiltInExecutor|null[0]
    constructor <init>(kotlin/String, kotlin/Array<out kotlin/String>) // kotlinx.benchmark.wasm/WasmBuiltInExecutor.<init>|<init>(kotlin.String;kotlin.Array<out|kotlin.String>){}[0]
}
